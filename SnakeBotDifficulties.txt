//ZIGZAGbool SnakeClient::_bot(){    Directions dir = _direction;    if (_FIELD_HEIGHT % 2 &&        (_homeDots[0].x() == _FIELD_WIDTH - 1 &&        (_homeDots[0].y() == _FIELD_HEIGHT - 1 ||        _homeDots[0].y() == 0)))        _isDown = !_isDown;    if (!(_FIELD_HEIGHT % 2) &&       (_homeDots[0].x() == 0 &&       (_homeDots[0].y() == _FIELD_HEIGHT - 1 ||       _homeDots[0].y() == 0)))        _isDown = !_isDown;    if ((dir == down || dir == up) && _homeDots[0].x() == 0)        dir = right;    else if ((dir == down || dir == up) && _homeDots[0].x() == _FIELD_WIDTH - 1)        dir = left;    else if (dir == right &&             (_homeDots[0].x() == 0 || _homeDots[0].x() == _FIELD_WIDTH - 1))    {        if (_homeDots[0].y() == _FIELD_HEIGHT - 1)            dir = up;        else if (_homeDots[0].y() == 0)            dir = down;        else if (_homeDots[0].y() % 2)            dir = _isDown ? up : down;        else            dir = _isDown ? down : up;    }    else if (dir == left &&             (_homeDots[0].x() == 0 || _homeDots[0].x() == _FIELD_WIDTH - 1))    {        if (_homeDots[0].y() == _FIELD_HEIGHT - 1)            dir = up;        else if (_homeDots[0].y() == 0)            dir = down;        else if (_homeDots[0].y() % 2)            dir = _isDown ? down : up;        else            dir = _isDown ? up : down;    }    if (dir != _direction)    {        _direction = dir;        return true;    }    else        return false;}//SNAILbool SnakeClient::_bot(){    Directions dir = _direction;    if (dir == right && _homeDots[0].x() == _FIELD_WIDTH - 1 - _homeDots[0].y())        dir = down;    if (dir == down && _homeDots[0].x() == _homeDots[0].y())        dir = left;    if (dir == left && _homeDots[0].y() == _FIELD_HEIGHT - 1 - _homeDots[0].x())        dir = up;    if (dir == up && _homeDots[0].x() ==  _homeDots[0].y() - 1)        dir = right;    if (dir != _direction)    {        _direction = dir;        return true;    }    else        return false;}//ALMOST CLEVER SNAKEbool SnakeClient::_checkMove(Directions tmp){    if (tmp == up && _homeDots[0].y() == 0)        return false;    if (tmp == down && _homeDots[0].y() == _FIELD_HEIGHT - 1)        return false;    if (tmp == left && _homeDots[0].x() == 0)        return false;    if (tmp == right && _homeDots[0].x() == _FIELD_WIDTH - 1)        return false;    if (tmp == right)    {        QPoint p(_homeDots[0].x() + 1, _homeDots[0].y());        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;        for (auto snake : _enemiesDots)            for (size_t i = 0; i < snake.size(); i++)                if (p == snake[i])                    return false;    }    if (tmp == left)    {        QPoint p(_homeDots[0].x() - 1, _homeDots[0].y());        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;        for (auto snake : _enemiesDots)            for (size_t i = 0; i < snake.size(); i++)                if (p == snake[i])                    return false;    }    if (tmp == up)    {        QPoint p(_homeDots[0].x(), _homeDots[0].y() - 1);        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;        for (auto snake : _enemiesDots)            for (size_t i = 0; i < snake.size(); i++)                if (p == snake[i])                    return false;    }    if (tmp == down)    {        QPoint p(_homeDots[0].x(), _homeDots[0].y() + 1);        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;        for (auto snake : _enemiesDots)            for (size_t i = 0; i < snake.size(); i++)                if (p == snake[i])                    return false;    }    return true;}bool SnakeClient::_bot(){    Directions dir;    size_t length = abs(_homeDots[0].x() - _fruits[0].x()) + abs(_homeDots[0].y() - _fruits[0].y());    QPoint goal = _fruits[0];    for (size_t i = 1; i < _fruits.size(); i++)    {        if (length > abs(_homeDots[0].x() - _fruits[i].x()) + abs(_homeDots[0].y() - _fruits[i].y()))        {            goal = _fruits[i];            length = abs(_homeDots[0].x() - _fruits[i].x()) + abs(_homeDots[0].y() - _fruits[i].y());        }    }    if (_homeDots[0].x() == goal.x())    {        dir = (_homeDots[0].y() > goal.y() ? up : down);        if (!_checkMove(dir))        {            if (_checkMove(left))                dir = left;            else if (_checkMove(dir == down ? up : down))                dir = (dir == down ? up : down);            else if (_checkMove(right))                dir = right;        }    }    else if (_homeDots[0].y() == goal.y())    {        dir = (_homeDots[0].x() > goal.x() ? left : right);        if (!_checkMove(dir))        {            if (_checkMove(up))                dir = up;            else if (_checkMove(dir == left ? right : left))                dir = (dir == left ? right : left);            else if (_checkMove(down))                dir = down;        }    }    else    {        dir = (_homeDots[0].x() > goal.x() ? left : right);        if (!_checkMove(dir))        {            Directions tmp = _homeDots[0].y() > goal.y() ? up : down;            if (_checkMove(tmp))                dir = tmp;            else if (_checkMove(tmp == up ? down : up))                dir = (tmp == up ? down : up);            else if (_checkMove(dir == left ? right : left))                dir = (dir == left ? right : left);        }    }    if (!_checkMove(dir))        return false;    else if (dir != _direction)    {        _direction = dir;        return true;    }    else        return false;}// VERY CLEVER SNAKEbool SnakeClient::_checkMove(Directions tmp){    if (tmp == up && _homeDots[0].y() == 0)        return false;    if (tmp == down && _homeDots[0].y() == _FIELD_HEIGHT - 1)        return false;    if (tmp == left && _homeDots[0].x() == 0)        return false;    if (tmp == right && _homeDots[0].x() == _FIELD_WIDTH - 1)        return false;    if (tmp == right)    {        QPoint p(_homeDots[0].x() + 1, _homeDots[0].y());        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;    }    if (tmp == left)    {        QPoint p(_homeDots[0].x() - 1, _homeDots[0].y());        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;    }    if (tmp == up)    {        QPoint p(_homeDots[0].x(), _homeDots[0].y() - 1);        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;    }    if (tmp == down)    {        QPoint p(_homeDots[0].x(), _homeDots[0].y() + 1);        for (size_t i = 1; i < _homeDots.size(); i++)            if (p == _homeDots[i])                return false;    }    return true;}bool SnakeClient::_bot(){    Directions dir;    size_t length = abs(_homeDots[0].x() - _fruits[0].x()) + abs(_homeDots[0].y() - _fruits[0].y());    QPoint goal = _fruits[0];    for (size_t i = 1; i < _fruits.size(); i++)    {        if (length > abs(_homeDots[0].x() - _fruits[i].x()) + abs(_homeDots[0].y() - _fruits[i].y()))        {            goal = _fruits[i];            length = abs(_homeDots[0].x() - _fruits[i].x()) + abs(_homeDots[0].y() - _fruits[i].y());        }    }    if (_homeDots[0].x() == goal.x())    {        dir = (_homeDots[0].y() > goal.y() ? up : down);        if (!_checkMove(dir))        {            if (_checkMove(left))                dir = left;            else if (_checkMove(dir == down ? up : down))                dir = (dir == down ? up : down);            else if (_checkMove(right))                dir = right;        }    }    else if (_homeDots[0].y() == goal.y())    {        dir = (_homeDots[0].x() > goal.x() ? left : right);        if (!_checkMove(dir))        {            if (_checkMove(up))                dir = up;            else if (_checkMove(dir == left ? right : left))                dir = (dir == left ? right : left);            else if (_checkMove(down))                dir = down;        }    }    else    {        dir = (_homeDots[0].x() > goal.x() ? left : right);        if (!_checkMove(dir))        {            Directions tmp = _homeDots[0].y() > goal.y() ? up : down;            if (_checkMove(tmp))                dir = tmp;            else if (_checkMove(tmp == up ? down : up))                dir = (tmp == up ? down : up);            else if (_checkMove(dir == left ? right : left))                dir = (dir == left ? right : left);        }    }    if (!_checkMove(dir))        return false;    else if (dir != _direction)    {        _direction = dir;        return true;    }    else        return false;}